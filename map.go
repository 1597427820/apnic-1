/*
 *  Copyright (c) 2011-2013, foxae.com/microfox.me
 *
 *  This file is part of Apnic, an IP region querier library.
 *  Contact: info@microfox.me
 *
 *  All rights reserved.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

package apnic

import (
	"encoding/json"
	"sort"
	"net"
)

type Entry struct {
	N	uint32	// network mask, ipv4
	IP	[]byte	// type net.IP
	Mask	[]byte	// type net.IPMask
	mask	uint32
}

// Map variable should be generated by Makefile.
// The field m must be properly sorted.
type Map struct {
	m	[]*Entry
}

// IPInPRC returns true if the given ip lives in PRC.
func IPInPRC(ip net.IP) bool {
	return prcMap.ContainsIP(ip)
}

// InPRC checks whether a given IPv4 value is a PRC IP address.
func InPRC(ip uint32) bool {
	return prcMap.Contains(ip)
}

func (m Map) ContainsIP(ip net.IP) bool {
	n := len(ip)
	i := ntoh(ip[n-4], ip[n-3], ip[n-2], ip[n-1])
	return m.Contains(i)
}

func (m Map) Contains(ip uint32) bool {
	i, j := 0, len(m.m)
	for i < j {
		h := i + (j-i)/2
		//fmt.Printf("%d: %v\n", h, m.m[h].IP)
		if en := m.m[h]; ip > en.N && (ip & en.mask) != en.N {
			i = h + 1
		} else {
			j = h
		}
	}
	if i >= len(m.m) {
		return false
	}
	//fmt.Printf("%d: %v, %v, 0x%08x\n", i, m.m[i].IP, m.m[i].Mask, m.m[i].mask)
	if en := m.m[i]; en.mask & ip  == en.N {
		return true
	}
	return false
}

func LoadFromJSON(p []byte) (Map, error) {
	var x []*Entry
	if e := json.Unmarshal(p, &x); e != nil {
		return Map{}, e
	}
	sort.Sort(entries(x))
	for _, y := range x {
		n := len(y.Mask)
		y.mask = ntoh(y.Mask[n-4], y.Mask[n-3], y.Mask[n-2], y.Mask[n-1])
	}
	return Map{m:x}, nil
}

type entries []*Entry

func (list entries) Len() int {
	return len(list)
}

func (list entries) Swap(i, j int) {
	list[i], list[j] = list[j], list[i]
}

func (list entries) Less(i, j int) bool {
	return list[i].N < list[j].N
}

func ntoh(a, b, c, d byte) uint32 {
	return uint32(a) << 24 | uint32(b) << 16 | uint32(c) << 8 | uint32(d)
}
